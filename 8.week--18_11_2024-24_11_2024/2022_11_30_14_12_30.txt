MATLAB OTURUMU BAŞARILI BİR ŞEKİLDE AÇILDI...
help trapz
 <strong>trapz</strong>  Trapezoidal numerical integration.
    Z = <strong>trapz</strong>(Y) computes an approximation of the integral of Y via
    the trapezoidal method (with unit spacing).  To compute the integral
    for spacing different from one, multiply Z by the spacing increment.
 
    For vectors, <strong>trapz</strong>(Y) is the integral of Y. For matrices, <strong>trapz</strong>(Y)
    is a row vector with the integral over each column. For N-D
    arrays, <strong>trapz</strong>(Y) works across the first non-singleton dimension.
 
    Z = <strong>trapz</strong>(X,Y) computes the integral of Y with respect to X using the
    trapezoidal method. X can be a scalar or a vector with the same length
    as the first non-singleton dimension in Y. <strong>trapz</strong> operates along this
    dimension. If X is scalar, then <strong>trapz</strong>(X,Y) is equivalent to X*<strong>trapz</strong>(Y).
 
    Z = <strong>trapz</strong>(X,Y,DIM) or <strong>trapz</strong>(Y,DIM) integrates across dimension DIM
    of Y. The length of X must be the same as size(Y,DIM)).
 
    Example:
        Y = [0 1 2; 3 4 5]
        trapz(Y,1)
        trapz(Y,2)
 
    Class support for inputs X, Y:
       float: double, single
 
    See also <a href="matlab:help sum">sum</a>, <a href="matlab:help cumsum">cumsum</a>, <a href="matlab:help cumtrapz">cumtrapz</a>, <a href="matlab:help integral">integral</a>.

    <a href="matlab:doc trapz">Documentation for trapz</a>
    <a href="matlab:matlab.internal.language.introspective.overloads.displayOverloads('trapz')">Other functions named trapz</a>

help simp
--- <strong>simp</strong> not found. Showing help for <strong>sim</strong> instead. ---

 <strong>sim</strong> Simulate a Simulink model
 
    SimOut = <strong>sim</strong>('MODEL', PARAMETERS) simulates your Simulink model, where 
    'PARAMETERS' represents a list of parameter name-value pairs, a structure 
    containing parameter settings, or a configuration set. The SimOut
    returned by the <strong>sim</strong> command is an object that contains all of the logged
    simulation results. Optional PARAMETERS can be used to override existing 
    block diagram configuration parameters for the duration of the simulation.
 
    This syntax is referred to as the 'Single-Output Format'.
 
    SINGLE-OUTPUT FORMAT
    --------------------
    SimOut = <strong>sim</strong>('MODEL','PARAMETER_NAME1',VALUE1,'PARAMETER_NAME2',VALUE2, ...)
    SimOut = <strong>sim</strong>('MODEL', PARAM_NAME_VAL_STRUCT)
    SimOut = <strong>sim</strong>('MODEL', CONFIGSET)
 
    All simulation outputs (logged time, states, and signals) are returned in a
    single Simulink.SimulationOutput object. Using the model's Configuration
    Parameters Data Import/Export dialog, you define the model time, states, and
    output to be logged. You can log signals using blocks such as the
    To Workspace and Scope blocks. The Signal & Scope Manager can directly
    log signals.
 
    Where:
 
      SimOut                : Returned Simulink.SimulationOutput object
                              containing all of the simulation output.
      'MODEL'               : Name of a block diagram model.
      'PARAMETER_NAME'      : Name of the Configuration or Block Diagram
                              parameter.
      VALUE                 : Value of the corresponding Configuration or
                              Block Diagram parameter.
      PARAM_NAME_VAL_STRUCT : This is a structure whose fields are the names
                              of the block diagram or the configuration
                              parameters that are being changed for the
                              simulation. The corresponding values are
                              the corresponding parameter values.
      CONFIGSET             : The set of configuration parameters for a model.
 
    The single-output format makes the <strong>sim</strong> command compatible with PARFOR
    by eliminating any transparency issues. See "Running Parallel
    Simulations" in the Simulink documentation for further details.
 
    Example 1:
      simOut = sim('vdp','SimulationMode','rapid','AbsTol','1e-5',...
                   'SaveState','on','StateSaveName','xoutNew',...
                   'SaveOutput','on','OutputSaveName','youtNew');
      simOutVars = simOut.who;
      yout = simOut.find('youtNew');
 
 
    Example 2:
      paramNameValStruct.SimulationMode = 'rapid';
      paramNameValStruct.AbsTol         = '1e-5';
      paramNameValStruct.SaveState      = 'on';
      paramNameValStruct.StateSaveName  = 'xoutNew';
      paramNameValStruct.SaveOutput     = 'on';
      paramNameValStruct.OutputSaveName = 'youtNew';
      simOut = sim('vdp',paramNameValStruct);
 
    Example 3:
      mdl = 'vdp';
      load_system(mdl);
      simMode = get_param(mdl, 'SimulationMode');
      set_param(mdl, 'SimulationMode', 'rapid');
      cs = getActiveConfigSet(mdl);
      mdl_cs = cs.copy;
      set_param(mdl_cs,'AbsTol','1e-5',...
                'SaveState','on','StateSaveName','xoutNew',...
                'SaveOutput','on','OutputSaveName','youtNew');
      simOut = sim(mdl, mdl_cs);
      set_param(mdl, 'SimulationMode', simMode);
 
    DEFAULTS:
 
      1.  R = <strong>sim</strong>('MODEL') returns the result R as either a 
          Simulink.SimulationOutput object or a time vector that is compatible 
          with a Simulink version prior to 7.4 (R2009b).
 
          To make <strong>sim</strong>('MODEL') return in the single-output format, use the
          ReturnWorkspaceOutputs option:
 
          SimOut = <strong>sim</strong>('MODEL', 'ReturnWorkspaceOutputs', 'on')
 
 
      2.  To set the single-output format as the default format, select the
          'Return as single output' option on the Data Import/Export pane of 
          the Configuration Parameters dialog box and save the model.
  
 
 
    See also <a href="matlab:help sldebug">sldebug</a>, <a href="matlab:help sim">sim</a> <a href="matlab:help sym/in">in</a> <a href="matlab:help parfor">parfor</a>

    <a href="matlab:doc sim">Documentation for sim</a>
    <a href="matlab:matlab.internal.language.introspective.overloads.displayOverloads('sim')">Other functions named sim</a>

clc
edit
ac=0:15:90

ac =

     0    15    30    45    60    75    90

acr=ac.*pi/180

acr =

         0    0.2618    0.5236    0.7854    1.0472    1.3090    1.5708

y=sin(acr)

y =

         0    0.2588    0.5000    0.7071    0.8660    0.9659    1.0000

[acr' y']

ans =

         0         0
    0.2618    0.2588
    0.5236    0.5000
    0.7854    0.7071
    1.0472    0.8660
    1.3090    0.9659
    1.5708    1.0000

simp(acr,y)

ans =

    1.0000

int('sin(x)')
{Check for missing argument or incorrect argument data type in call to function
'int'.
} 
syms x, int(sin(x),0,90)
 
ans =
 
1 - cos(90)
 
simp(acr,y)

ans =

    1.0000

help quadl
 <strong>quadl</strong>  Numerically evaluate integral, adaptive Lobatto quadrature.
    Q = <strong>quadl</strong>(FUN,A,B) tries to approximate the integral of scalar-valued
    function FUN from A to B to within an error of 1.e-6 using high order
    recursive adaptive quadrature.  FUN is a function handle. The function
    Y=FUN(X) should accept a vector argument X and return a vector result
    Y, the integrand evaluated at each element of X.
 
    Q = <strong>quadl</strong>(FUN,A,B,TOL) uses an absolute error tolerance of TOL
    instead of the default, which is 1.e-6.  Larger values of TOL
    result in fewer function evaluations and faster computation,
    but less accurate results.
 
    Q = <strong>quadl</strong>(FUN,A,B,TOL,TRACE) with non-zero TRACE shows the values
    of [fcnt a b-a Q] during the recursion. Use [] as a placeholder to
    obtain the default value of TOL.
 
    [Q,FCNT] = <strong>quadl</strong>(...) returns the number of function evaluations.
 
    Use array operators .*, ./ and .^ in the definition of FUN
    so that it can be evaluated with a vector argument.
 
    <strong>quadl</strong> will be removed in a future release. Use INTEGRAL instead.
 
    Example:
       Q = quadl(@myfun,0,2);
    where the file myfun.m defines the function:
       %-------------------%
       function y = myfun(x)
       y = 1./(x.^3-2*x-5);
       %-------------------%
 
    or, use a parameter for the constant:
       Q = quadl(@(x)myfun2(x,5),0,2);
    where the file myfun2.m defines the function:
       %----------------------%
       function y = myfun2(x,c)
       y = 1./(x.^3-2*x-c);
       %----------------------%
 
    Class support for inputs A, B, and the output of FUN:
       float: double, single
 
    See also <a href="matlab:help integral">integral</a>, <a href="matlab:help integral2">integral2</a>, <a href="matlab:help integral3">integral3</a>, <a href="matlab:help quadgk">quadgk</a>, <a href="matlab:help quad2d">quad2d</a>, <a href="matlab:help trapz">trapz</a>, ...
    <a href="matlab:help function_handle">function_handle</a>.

    <a href="matlab:doc quadl">Documentation for quadl</a>

clc
hp=@hparabola

hp =

  <a href="matlab:helpPopup function_handle" style="font-weight:bold">function_handle</a> with value:

    @hparabola

quadl(hp,1,-1)

ans =

   -4.0000

quadl(hp,-1,1)

ans =

    4.0000

fplot(hp,[-1 1])
grid
clc
ip=inline('-3*x^2+3','x')

ip =

     Inline function:
     ip(x) = -3*x^2+3

fplot(ip,[-1 1])
fplot(ip,[-1, 1])
fplot(ip)
ip

ip =

     Inline function:
     ip(x) = -3*x^2+3

y=ip([-1:.1:1])
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('inlineeval', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\inlineeval.m', 14)" style="font-weight:bold">inlineeval</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\inlineeval.m',14,0)">line 14</a>)
Error in inline expression ==> -3*x^2+3
 Incorrect dimensions for raising a matrix to a power. Check that the matrix is
 square and the power is a scalar. To perform elementwise matrix powers, use
 '.^'.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('inline/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\@inline\subsref.m', 23)" style="font-weight:bold">inline/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\@inline\subsref.m',23,0)">line 23</a>)
    INLINE_OUT_ = inlineeval(INLINE_INPUTS_, INLINE_OBJ_.inputExpr,
    INLINE_OBJ_.expr);
} 
y=ip(.3)

y =

    2.7300

y=ip([.1 .3])
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('inlineeval', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\inlineeval.m', 14)" style="font-weight:bold">inlineeval</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\inlineeval.m',14,0)">line 14</a>)
Error in inline expression ==> -3*x^2+3
 Incorrect dimensions for raising a matrix to a power. Check that the matrix is
 square and the power is a scalar. To perform elementwise matrix powers, use
 '.^'.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('inline/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\@inline\subsref.m', 23)" style="font-weight:bold">inline/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\@inline\subsref.m',23,0)">line 23</a>)
    INLINE_OUT_ = inlineeval(INLINE_INPUTS_, INLINE_OBJ_.inputExpr,
    INLINE_OBJ_.expr);
} 
y=ip([.1 .3]')
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('inlineeval', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\inlineeval.m', 14)" style="font-weight:bold">inlineeval</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\inlineeval.m',14,0)">line 14</a>)
Error in inline expression ==> -3*x^2+3
 Incorrect dimensions for raising a matrix to a power. Check that the matrix is
 square and the power is a scalar. To perform elementwise matrix powers, use
 '.^'.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('inline/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\@inline\subsref.m', 23)" style="font-weight:bold">inline/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\funfun\@inline\subsref.m',23,0)">line 23</a>)
    INLINE_OUT_ = inlineeval(INLINE_INPUTS_, INLINE_OBJ_.inputExpr,
    INLINE_OBJ_.expr);
} 
ip=inline('-3*x.^2+3','x')

ip =

     Inline function:
     ip(x) = -3*x.^2+3

fplot(ip,[-1, 1])
ip([-1:.1:1])

ans =

  Columns 1 through 8

         0    0.5700    1.0800    1.5300    1.9200    2.2500    2.5200    2.7300

  Columns 9 through 16

    2.8800    2.9700    3.0000    2.9700    2.8800    2.7300    2.5200    2.2500

  Columns 17 through 21

    1.9200    1.5300    1.0800    0.5700         0

fplot(ip,[-1 1])
fplot(ip,[-1,1])
fplot(ip,lispace(-1,1))
{Unrecognized function or variable 'lispace'.
} 
fplot(ip,linspace(-1,1))
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('fplot', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m', 149)" style="font-weight:bold">fplot</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m',149,0)">line 149</a>)
Invalid parameter '-1     ...'.
} 
linspace(-1,1)

ans =

  Columns 1 through 8

   -1.0000   -0.9798   -0.9596   -0.9394   -0.9192   -0.8990   -0.8788   -0.8586

  Columns 9 through 16

   -0.8384   -0.8182   -0.7980   -0.7778   -0.7576   -0.7374   -0.7172   -0.6970

  Columns 17 through 24

   -0.6768   -0.6566   -0.6364   -0.6162   -0.5960   -0.5758   -0.5556   -0.5354

  Columns 25 through 32

   -0.5152   -0.4949   -0.4747   -0.4545   -0.4343   -0.4141   -0.3939   -0.3737

  Columns 33 through 40

   -0.3535   -0.3333   -0.3131   -0.2929   -0.2727   -0.2525   -0.2323   -0.2121

  Columns 41 through 48

   -0.1919   -0.1717   -0.1515   -0.1313   -0.1111   -0.0909   -0.0707   -0.0505

  Columns 49 through 56

   -0.0303   -0.0101    0.0101    0.0303    0.0505    0.0707    0.0909    0.1111

  Columns 57 through 64

    0.1313    0.1515    0.1717    0.1919    0.2121    0.2323    0.2525    0.2727

  Columns 65 through 72

    0.2929    0.3131    0.3333    0.3535    0.3737    0.3939    0.4141    0.4343

  Columns 73 through 80

    0.4545    0.4747    0.4949    0.5152    0.5354    0.5556    0.5758    0.5960

  Columns 81 through 88

    0.6162    0.6364    0.6566    0.6768    0.6970    0.7172    0.7374    0.7576

  Columns 89 through 96

    0.7778    0.7980    0.8182    0.8384    0.8586    0.8788    0.8990    0.9192

  Columns 97 through 100

    0.9394    0.9596    0.9798    1.0000

clc
fplot(ip,linspace(-1,1))
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('fplot', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m', 149)" style="font-weight:bold">fplot</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m',149,0)">line 149</a>)
Invalid parameter '-1     ...'.
} 
fplot(ip,linspace(-1,1)')
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('fplot', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m', 149)" style="font-weight:bold">fplot</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m',149,0)">line 149</a>)
Invalid parameter '       ...'.
} 
fplot(ip,[0.1, 0.4])
fplot(ip,[0.1, 0.4],'r-*')
fplot(ip,0.4)
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('fplot', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m', 149)" style="font-weight:bold">fplot</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m',149,0)">line 149</a>)
Invalid parameter '0.4'.
} 
help fplot
 <strong>fplot</strong>   Plot 2-D function
    <strong>fplot</strong>(FUN) plots the function FUN between the limits of the current
    axes, with a default of [-5 5].
 
    <strong>fplot</strong>(FUN,LIMS) plots the function FUN between the x-axis limits
    specified by LIMS = [XMIN XMAX]. 
 
    <strong>fplot</strong>(...,'LineSpec') plots with the given line specification.
 
    <strong>fplot</strong>(X,Y,LIMS) plots the parameterized curve with coordinates
    X(T), Y(T) for T between the values specified by LIMS = [TMIN TMAX].
 
    H = <strong>fplot</strong>(...) returns a handle to the function line object created by <strong>fplot</strong>.
 
    <strong>fplot</strong>(AX,...) plots into the axes AX instead of the current axes.
 
    Examples:
        fplot(@sin)
        fplot(@(x) x.^2.*sin(1./x),[-1,1])
        fplot(@(x) sin(1./x), [0 0.1])
 
    If your function cannot be evaluated for multiple x values at once,
    you will get a warning and somewhat reduced speed:
        f = @(x,n) abs(exp(-1j*x*(0:n-1))*ones(n,1));
        fplot(@(x) f(x,10),[0 2*pi])
 
    See also <a href="matlab:help fplot3">fplot3</a>, <a href="matlab:help fsurf">fsurf</a>, <a href="matlab:help fcontour">fcontour</a>, <a href="matlab:help fimplicit">fimplicit</a>, <a href="matlab:help plot">plot</a>, <a href="matlab:help function_handle">function_handle</a>.

    <a href="matlab:doc fplot">Documentation for fplot</a>

fplot(ip,[0.1 0.4],'r-*')
fplot(@ip,[0.1 0.4],'r-*')
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('nargin')" style="font-weight:bold">nargin</a>
Function ip does not exist.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('fplot', 'C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m', 115)" style="font-weight:bold">fplot</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\matlab\graphics\function\fplot.m',115,0)">line 115</a>)
        if isa(fn{k},'function_handle') && nargin(fn{k}) > 1
} 
ip

ip =

     Inline function:
     ip(x) = -3*x.^2+3

quadl(ip,-1,1)

ans =

    4.0000

help fplot
 <strong>fplot</strong>   Plot 2-D function
    <strong>fplot</strong>(FUN) plots the function FUN between the limits of the current
    axes, with a default of [-5 5].
 
    <strong>fplot</strong>(FUN,LIMS) plots the function FUN between the x-axis limits
    specified by LIMS = [XMIN XMAX]. 
 
    <strong>fplot</strong>(...,'LineSpec') plots with the given line specification.
 
    <strong>fplot</strong>(X,Y,LIMS) plots the parameterized curve with coordinates
    X(T), Y(T) for T between the values specified by LIMS = [TMIN TMAX].
 
    H = <strong>fplot</strong>(...) returns a handle to the function line object created by <strong>fplot</strong>.
 
    <strong>fplot</strong>(AX,...) plots into the axes AX instead of the current axes.
 
    Examples:
        fplot(@sin)
        fplot(@(x) x.^2.*sin(1./x),[-1,1])
        fplot(@(x) sin(1./x), [0 0.1])
 
    If your function cannot be evaluated for multiple x values at once,
    you will get a warning and somewhat reduced speed:
        f = @(x,n) abs(exp(-1j*x*(0:n-1))*ones(n,1));
        fplot(@(x) f(x,10),[0 2*pi])
 
    See also <a href="matlab:help fplot3">fplot3</a>, <a href="matlab:help fsurf">fsurf</a>, <a href="matlab:help fcontour">fcontour</a>, <a href="matlab:help fimplicit">fimplicit</a>, <a href="matlab:help plot">plot</a>, <a href="matlab:help function_handle">function_handle</a>.

    <a href="matlab:doc fplot">Documentation for fplot</a>

 fplot(@sin)
        fplot(@(x) x.^2.*sin(1./x),[-1,1])
        fplot(@(x) sin(1./x), [0 0.1])
fplot(@sin)
fplot(@(x) x.^2.*sin(1./x),[-1,1])
fplot(@(x) x.^2.*sin(1./x),[-1,1])
fplot(ip,[-1, 1],'r-*')
fplot(@(ip),[-1, 1],'r-*')
 fplot(@(ip),[-1, 1],'r-*')
            ↑
{Error: Invalid expression. When calling a function or indexing a variable, use
parentheses. Otherwise, check for mismatched delimiters.
} 
fplot(ip,[-1, 1],'r-*')
clc
_swiss
 _swiss
 ↑
{Error: Invalid text character. Check for unsupported symbol, invisible character,
or pasting of non-ASCII characters.
} 
h_swiss
{Unrecognized function or variable 'h_swiss'.
} 
h_swiss_
swiss=40*swiss/18

swiss =

   15.5556   97.7778   97.7778
   23.3333  100.0000  131.1111
   28.8889  104.4444  155.5556
   38.8889  111.1111  160.0000
   75.5556  111.1111  206.6667
   90.0000   84.4444  222.2222
   98.8889   66.6667  244.4444
  106.6667   66.6667  244.4444
  124.4444   75.5556  244.4444
  135.5556   80.0000  260.0000
  152.2222   75.5556  262.2222
  170.0000   91.1111  257.7778
  178.8889  100.0000  262.2222
  202.2222  102.2222  262.2222
  213.3333   95.5556  268.8889
  224.4444   82.2222  275.5556
  231.1111   73.3333  268.8889
  236.6667   62.2222  268.8889
  247.7778   71.1111  268.8889
  262.2222  144.4444  271.1111
  274.4444  122.2222  257.7778
  303.3333  120.0000  184.4444
  315.5556  115.5556  180.0000
  324.4444  111.1111  182.2222
  333.3333  146.6667  191.1111
  348.8889  146.6667  188.8889
  351.1111  151.1111  151.1111

long=swiss(:,1)

long =

   15.5556
   23.3333
   28.8889
   38.8889
   75.5556
   90.0000
   98.8889
  106.6667
  124.4444
  135.5556
  152.2222
  170.0000
  178.8889
  202.2222
  213.3333
  224.4444
  231.1111
  236.6667
  247.7778
  262.2222
  274.4444
  303.3333
  315.5556
  324.4444
  333.3333
  348.8889
  351.1111

lat_down=swiss(:,2)

lat_down =

   97.7778
  100.0000
  104.4444
  111.1111
  111.1111
   84.4444
   66.6667
   66.6667
   75.5556
   80.0000
   75.5556
   91.1111
  100.0000
  102.2222
   95.5556
   82.2222
   73.3333
   62.2222
   71.1111
  144.4444
  122.2222
  120.0000
  115.5556
  111.1111
  146.6667
  146.6667
  151.1111

lat_up=swiss(:,3)

lat_up =

   97.7778
  131.1111
  155.5556
  160.0000
  206.6667
  222.2222
  244.4444
  244.4444
  244.4444
  260.0000
  262.2222
  257.7778
  262.2222
  262.2222
  268.8889
  275.5556
  268.8889
  268.8889
  268.8889
  271.1111
  257.7778
  184.4444
  180.0000
  182.2222
  191.1111
  188.8889
  151.1111

plot(long,lat_down)
axis('off')
axis('equal')
hold on
plot(long,lat_up))
 plot(long,lat_up))
                  ↑
{Error: Invalid expression. When calling a function or indexing a variable, use
parentheses. Otherwise, check for mismatched delimiters.
} 
plot(long,lat_up)
scale=40*[10 28]/18

scale =

   22.2222   62.2222

plot(scale,[10 10])
plot(scale,[10 10])
plot(long,lat_down)
hold on
plot(long,lat_up)
axis('equal')
axis('off')
plot(scale,[10 10])
text(15,10,'0')
text(70,10,'40 km')
breadth=lat_up-lat_down

breadth =

         0
   31.1111
   51.1111
   48.8889
   95.5556
  137.7778
  177.7778
  177.7778
  168.8889
  180.0000
  186.6667
  166.6667
  162.2222
  160.0000
  173.3333
  193.3333
  195.5556
  206.6667
  197.7778
  126.6667
  135.5556
   64.4444
   64.4444
   71.1111
   44.4444
   42.2222
         0

alan=trapz(long,breadth)

alan =

   4.2414e+04

%41288
alan-41288

ans =

   1.1256e+03

abs(alan-41288)/41288

ans =

    0.0273

abs(alan-41288)/41288*100

ans =

    2.7262

clc
clear

%f(t)=3*t 3*int(t*e^(-s*t))
syms t s
help laplace
--- help for <strong>sym/laplace</strong> ---

 <strong>laplace</strong> Laplace transform.
    L = <strong>laplace</strong>(F) is the Laplace transform of the sym F with default
    independent variable t.  The default return is a function of s.
    If F = F(s), then <strong>laplace</strong> returns a function of z:  L = L(z).
    By definition, L(s) = int(F(t)*exp(-s*t),t,0,inf).
 
    L = <strong>laplace</strong>(F,z) makes L a function of z instead of the default s:
    <strong>laplace</strong>(F,z) <=> L(z) = int(F(t)*exp(-z*t),t,0,inf).
 
    L = <strong>laplace</strong>(F,w,u) makes L a function of u instead of the
    default s (integration with respect to w).
    <strong>laplace</strong>(F,w,u) <=> L(u) = int(F(w)*exp(-u*w),w,0,inf).
 
    Examples:
     syms a s t w x F(t)
     laplace(t^5)          returns   120/s^6
     laplace(exp(a*s))     returns   -1/(a-z)
     laplace(sin(w*x),t)   returns   w/(t^2+w^2)
     laplace(cos(x*w),w,t) returns   t/(t^2+x^2)
     laplace(x^(3/2),t)    returns   (3*pi^(1/2))/(4*t^(5/2))
     laplace(diff(F(t)))   returns   s*laplace(F(t),t,s) - F(0)
 
    See also <a href="matlab:help sym/ilaplace">sym/ilaplace</a>, <a href="matlab:help sym/fourier">sym/fourier</a>, <a href="matlab:help sym/htrans">sym/htrans</a>, <a href="matlab:help sym/ztrans">sym/ztrans</a>, <a href="matlab:help sym/subs">subs</a>.

laplace(3*t)
 
ans =
 
3/s^2
 
rs=laplace(3*t)
 
rs =
 
3/s^2
 
rt=ilaplace(rs)
 
rt =
 
3*t
 
rs=laplace(t^2)
 
rs =
 
2/s^3
 
%dsolve
%3/((s+1)*(s+2)*(s+3))
F_s=3/((s+1)*(s+2)*(s+3))
 
F_s =
 
3/((s + 1)*(s + 2)*(s + 3))
 
F_t=ilaplace(F_s)
 
F_t =
 
(3*exp(-t))/2 - 3*exp(-2*t) + (3*exp(-3*t))/2
 
F_s=(5*s+3)/((s+1)*(s+2)*(s+3))
 
F_s =
 
(5*s + 3)/((s + 1)*(s + 2)*(s + 3))
 
F_t=ilaplace(F_s)
 
F_t =
 
7*exp(-2*t) - exp(-t) - 6*exp(-3*t)
 
clc
R=[1 2 1 -1;3 4 2 1;-2 3 4 1;1 0 2 3]

R =

     1     2     1    -1
     3     4     2     1
    -2     3     4     1
     1     0     2     3

E=[1 -1 0 2]'

E =

     1
    -1
     0
     2

T=[R E]

T =

     1     2     1    -1     1
     3     4     2     1    -1
    -2     3     4     1     0
     1     0     2     3     2

gauss_eleme

T =

     1     2     1    -1     1
     3     4     2     1    -1
    -2     3     4     1     0
     1     0     2     3     2

    1.0000    2.0000    1.0000   -1.0000    1.0000
         0   -2.0000   -1.0000    4.0000   -4.0000
         0         0    2.5000   13.0000  -12.0000
         0         0         0  -10.4000   14.6000

I=zeros(1,sat);
I(4)=T(4,5)/T(4,4)

I =

         0         0         0   -1.4038

I(3)=(T(3,5)-T(3,4)*I(4))/T(3,3)

I =

         0         0    2.5000   -1.4038

I=zeros(1,sat);
%I(4)=T(4,5)/T(4,4)
%I(3)=(T(3,5)-T(3,4)*I(4))/T(3,3)
%I(2)=
%I(1)=
for n=sat:-1:1
    tp=T(n,[sut:-1:n+1]*I([sut:-1:n+1])';
     tp=T(n,[sut:-1:n+1]*I([sut:-1:n+1])';
                                         ↑
{Error: Invalid expression. When calling a function or indexing a variable, use
parentheses. Otherwise, check for mismatched delimiters.
} 
for n=sat:-1:1
    tp=T(n,[sut:-1:n+1]*I([sut:-1:n+1]);
     tp=T(n,[sut:-1:n+1]*I([sut:-1:n+1]);
                                        ↑
{Error: Invalid expression. When calling a function or indexing a variable, use
parentheses. Otherwise, check for mismatched delimiters.
} 
for n=sat:-1:1
    tp=T(n,[sut:-1:n+1])*I([sut:-1:n+1]);
    I(n)=(T(n,sut-1)-tp)/T(n,n);
end
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('mtimes')" style="font-weight:bold"> * </a>
Incorrect dimensions for matrix multiplication. Check that the number of columns
in the first matrix matches the number of rows in the second matrix. To perform
elementwise multiplication, use '.*'.

<a href="matlab:helpview('matlab','error_innerdim')" style="font-weight:bold">Related documentation</a>
} 
I

I =

     0     0     0     0

for n=sat:-1:1
    tp=T(n,[sut:-1:n+1])*I([sut:-1:n+1])';
    I(n)=(T(n,sut-1)-tp)/T(n,n);
end
disp(I)
     0     0     1     0

I=zeros(1,sat);
%I(4)=T(4,5)/T(4,4)
%I(3)=(T(3,5)-T(3,4)*I(4))/T(3,3)
%I(2)=
%I(1)=
for n=sat:-1:1
    tp=T(n,[sut:-1:n+1])*I([sut:-1:n+1])';
    I(n)=(T(n,sut+1)-tp)/T(n,n);
end
disp(I)
    1.2115   -2.0577    2.5000   -1.4038

I=zeros(1,sat)';
%I(4)=T(4,5)/T(4,4)
%I(3)=(T(3,5)-T(3,4)*I(4))/T(3,3)
%I(2)=
%I(1)=
for n=sat:-1:1
    tp=T(n,[sut:-1:n+1])*I([sut:-1:n+1]);
    I(n)=(T(n,sut+1)-tp)/T(n,n);
end
disp(I)
    1.2115
   -2.0577
    2.5000
   -1.4038

clc
clc
clear
clc
syms s, t
{Unrecognized function or variable 't'.
} 
syms s t
clc
F_s=1/(s+2)+1/(s+2)^2
 
F_s =
 
1/(s + 2) + 1/(s + 2)^2
 
simplify(F_s)
 
ans =
 
(s + 3)/(s + 2)^2
 
ilaplace(F_s)
 
ans =
 
exp(-2*t) + t*exp(-2*t)
 
help dsolve
 <strong>dsolve</strong> Symbolic solution of ordinary differential equations.
    <strong>dsolve</strong> will not accept equations as strings in a future release.
    Use symbolic expressions or sym objects instead.
    For example, use syms y(t); dsolve(diff(y)==y) instead of  dsolve('Dy=y').
 
    <strong>dsolve</strong>(eqn1,eqn2, ...) accepts symbolic equations representing
    ordinary differential equations and initial conditions. 
 
    By default, the independent variable is 't'. The independent variable
    may be changed from 't' to some other symbolic variable by including
    that variable as the last input argument.
 
    The DIFF function constructs derivatives of symbolic functions (see sym/symfun).
    Initial conditions involving derivatives must use an intermediate
    variable. For example,
      syms x(t)
      Dx = diff(x);
      dsolve(diff(Dx) == -x, Dx(0) == 1)
 
    If the number of initial conditions given is less than the
    number of dependent variables, the resulting solutions will obtain
    arbitrary constants, C1, C2, etc.
    
    Three different types of output are possible.  For one equation and one
    output, the resulting solution is returned, with multiple solutions to
    a nonlinear equation in a symbolic vector.  For several equations and
    an equal number of outputs, the results are sorted in lexicographic
    order and assigned to the outputs.  For several equations and a single
    output, a structure containing the solutions is returned.
 
    If no closed-form (explicit) solution is found, then a
    warning is given and the empty sym is returned.  
  
    <strong>dsolve</strong>(...,'IgnoreAnalyticConstraints',VAL) controls the level of 
    mathematical rigor to use on the analytical constraints of the solution 
    (branch cuts, division by zero, etc). The options for VAL are TRUE or 
    FALSE. Specify FALSE to use the highest level of mathematical rigor
    in finding any solutions. The default is TRUE.
 
    <strong>dsolve</strong>(...,'MaxDegree',n) controls the maximum degree of polynomials
    for which explicit formulas will be used in SOLVE calls during the
    computation. n must be a positive integer smaller than 5. 
    The default is 2.
 
    <strong>dsolve</strong>(...,'Implicit',true) returns the solution as a vector of
    equations, relating the dependent and the independent variable. This
    option is not allowed for systems of differential equations.
 
    <strong>dsolve</strong>(...,'ExpansionPoint',a) returns the solution as a series around
    the expansion point a.
 
    <strong>dsolve</strong>(...,'Order',n) returns the solution as a series with order n-1.
 
    Examples:
 
       % Example 1
       syms x(t) a
       dsolve(diff(x) == -a*x) returns
 
         ans = C1/exp(a*t)
 
       % Example 2: changing the independent variable 
       x = dsolve(diff(x) == -a*x, x(0) == 1, 's') returns
 
         x = 1/exp(a*s)
 
       syms x(s) a
       x = dsolve(diff(x) == -a*x, x(0) == 1) returns
 
         x = 1/exp(a*s)
 
       % Example 3: solving systems of ODEs
       syms f(t) g(t)
       S = dsolve(diff(f) == f + g, diff(g) == -f + g,f(0) == 1,g(0) == 2)
       returns a structure S with fields
 
         S.f = (i + 1/2)/exp(t*(i - 1)) - exp(t*(i + 1))*(i - 1/2)
         S.g = exp(t*(i + 1))*(i/2 + 1) - (i/2 - 1)/exp(t*(i - 1))
 
       syms f(t) g(t)
       v = [f;g];
       A = [1 1; -1 1];
       S = dsolve(diff(v) == A*v, v(0) == [1;2])
       returns a structure S with fields
 
         S.f = exp(t)*cos(t) + 2*exp(t)*sin(t)
         S.g = 2*exp(t)*cos(t) - exp(t)*sin(t)
 
       % Example 3: using options
       syms y(t)
       dsolve(sqrt(diff(y))==y) returns
       
         ans = 0
       
       syms y(t)
       dsolve(sqrt(diff(y))==y, 'IgnoreAnalyticConstraints', false) warns
         Warning: The solutions are subject to the following conditions:
         (C67 + t)*(1/(C67 + t)^2)^(1/2) = -1 
       
       and returns
        
         ans = -1/(C67 + t)
 
       % Example 4: Higher order systems
       syms y(t) a
       Dy = diff(y);
       D2y = diff(y,2);
       dsolve(D2y == -a^2*y, y(0) == 1, Dy(pi/a) == 0)
       syms w(t)
       Dw = diff(w); 
       D2w = diff(w,2);
       w = dsolve(diff(D2w) == -w, w(0)==1, Dw(0)==0, D2w(0)==0)
 
    See also <a href="matlab:help cgdivexpr/solve">solve</a>, <a href="matlab:help subs">subs</a>, <a href="matlab:help sym/diff">sym/diff</a>, <a href="matlab:help odeToVectorField">odeToVectorField</a>.

    <a href="matlab:doc dsolve">Documentation for dsolve</a>

syms x(t)
dx=diff(x(t))
 
dx =
 
diff(x(t), t)
 
dsolve(dx+2*x(t)-exp(-2*t), x(0) == 1)
 
ans =
 
exp(-2*t)*(t + 1)
 
dsolve(dx+2*x(t)-exp(-2*t), x(0) == 1,'s')
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('mupadengine/feval_internal')" style="font-weight:bold">mupadengine/feval_internal</a>
Invalid equation or initial condition.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('dsolve>mupadDsolve', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\dsolve.m', 334)" style="font-weight:bold">dsolve>mupadDsolve</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\dsolve.m',334,0)">line 334</a>)
T = feval_internal(symengine,'symobj::dsolve',sys,x,options);

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('dsolve', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\dsolve.m', 203)" style="font-weight:bold">dsolve</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\dsolve.m',203,0)">line 203</a>)
sol = mupadDsolve(args, options);
} 
dsolve(dx+2*x(t)-exp(-2*t), x(0) == 1)
 
ans =
 
exp(-2*t)*(t + 1)
 
dsolve(diff(dx)+5*dx+6*x(t),x(0)==0,dx(0)==7)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dsolve(diff(dx)+5*dx+6*x(t),[x(0)==0 dx(0)==7])
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dsolve(diff(dx)+5*dx+6*x(t),[x(0)==0,dx(0)==7])
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dsolve(diff(diff(x(t))+5*dx+6*x(t),[x(0)==0,dx(0)==7])
 dsolve(diff(diff(x(t))+5*dx+6*x(t),[x(0)==0,dx(0)==7])
                                                       ↑
{Error: Invalid expression. When calling a function or indexing a variable, use
parentheses. Otherwise, check for mismatched delimiters.
} 
dsolve(diff(diff(x(t))+5*dx+6*x(t),[x(0)==0,dx(0)==7]))
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dx=diff(x(t))
 
dx =
 
diff(x(t), t)
 
d2x=diff(dx)
 
d2x =
 
diff(x(t), t, t)
 
x
 
x(t) =
 
x(t)
 
dsolve(diff(diff(x))+5*dx+6*x,[x(0)==0,dx(0)==7]))
 dsolve(diff(diff(x))+5*dx+6*x,[x(0)==0,dx(0)==7]))
                                                  ↑
{Error: Invalid expression. When calling a function or indexing a variable, use
parentheses. Otherwise, check for mismatched delimiters.
} 
dsolve(d2x+5*dx+6*x,[x(0)==0,dx(0)==7]))
 dsolve(d2x+5*dx+6*x,[x(0)==0,dx(0)==7]))
                                        ↑
{Error: Invalid expression. When calling a function or indexing a variable, use
parentheses. Otherwise, check for mismatched delimiters.
} 
dsolve(d2x+5*dx+6*x,[x(0)==0,dx(0)==7])
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dsolve(d2x+5*dx+6*x,[x(0)==0 dx(0)==7])
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
help dsolve
 <strong>dsolve</strong> Symbolic solution of ordinary differential equations.
    <strong>dsolve</strong> will not accept equations as strings in a future release.
    Use symbolic expressions or sym objects instead.
    For example, use syms y(t); dsolve(diff(y)==y) instead of  dsolve('Dy=y').
 
    <strong>dsolve</strong>(eqn1,eqn2, ...) accepts symbolic equations representing
    ordinary differential equations and initial conditions. 
 
    By default, the independent variable is 't'. The independent variable
    may be changed from 't' to some other symbolic variable by including
    that variable as the last input argument.
 
    The DIFF function constructs derivatives of symbolic functions (see sym/symfun).
    Initial conditions involving derivatives must use an intermediate
    variable. For example,
      syms x(t)
      Dx = diff(x);
      dsolve(diff(Dx) == -x, Dx(0) == 1)
 
    If the number of initial conditions given is less than the
    number of dependent variables, the resulting solutions will obtain
    arbitrary constants, C1, C2, etc.
    
    Three different types of output are possible.  For one equation and one
    output, the resulting solution is returned, with multiple solutions to
    a nonlinear equation in a symbolic vector.  For several equations and
    an equal number of outputs, the results are sorted in lexicographic
    order and assigned to the outputs.  For several equations and a single
    output, a structure containing the solutions is returned.
 
    If no closed-form (explicit) solution is found, then a
    warning is given and the empty sym is returned.  
  
    <strong>dsolve</strong>(...,'IgnoreAnalyticConstraints',VAL) controls the level of 
    mathematical rigor to use on the analytical constraints of the solution 
    (branch cuts, division by zero, etc). The options for VAL are TRUE or 
    FALSE. Specify FALSE to use the highest level of mathematical rigor
    in finding any solutions. The default is TRUE.
 
    <strong>dsolve</strong>(...,'MaxDegree',n) controls the maximum degree of polynomials
    for which explicit formulas will be used in SOLVE calls during the
    computation. n must be a positive integer smaller than 5. 
    The default is 2.
 
    <strong>dsolve</strong>(...,'Implicit',true) returns the solution as a vector of
    equations, relating the dependent and the independent variable. This
    option is not allowed for systems of differential equations.
 
    <strong>dsolve</strong>(...,'ExpansionPoint',a) returns the solution as a series around
    the expansion point a.
 
    <strong>dsolve</strong>(...,'Order',n) returns the solution as a series with order n-1.
 
    Examples:
 
       % Example 1
       syms x(t) a
       dsolve(diff(x) == -a*x) returns
 
         ans = C1/exp(a*t)
 
       % Example 2: changing the independent variable 
       x = dsolve(diff(x) == -a*x, x(0) == 1, 's') returns
 
         x = 1/exp(a*s)
 
       syms x(s) a
       x = dsolve(diff(x) == -a*x, x(0) == 1) returns
 
         x = 1/exp(a*s)
 
       % Example 3: solving systems of ODEs
       syms f(t) g(t)
       S = dsolve(diff(f) == f + g, diff(g) == -f + g,f(0) == 1,g(0) == 2)
       returns a structure S with fields
 
         S.f = (i + 1/2)/exp(t*(i - 1)) - exp(t*(i + 1))*(i - 1/2)
         S.g = exp(t*(i + 1))*(i/2 + 1) - (i/2 - 1)/exp(t*(i - 1))
 
       syms f(t) g(t)
       v = [f;g];
       A = [1 1; -1 1];
       S = dsolve(diff(v) == A*v, v(0) == [1;2])
       returns a structure S with fields
 
         S.f = exp(t)*cos(t) + 2*exp(t)*sin(t)
         S.g = 2*exp(t)*cos(t) - exp(t)*sin(t)
 
       % Example 3: using options
       syms y(t)
       dsolve(sqrt(diff(y))==y) returns
       
         ans = 0
       
       syms y(t)
       dsolve(sqrt(diff(y))==y, 'IgnoreAnalyticConstraints', false) warns
         Warning: The solutions are subject to the following conditions:
         (C67 + t)*(1/(C67 + t)^2)^(1/2) = -1 
       
       and returns
        
         ans = -1/(C67 + t)
 
       % Example 4: Higher order systems
       syms y(t) a
       Dy = diff(y);
       D2y = diff(y,2);
       dsolve(D2y == -a^2*y, y(0) == 1, Dy(pi/a) == 0)
       syms w(t)
       Dw = diff(w); 
       D2w = diff(w,2);
       w = dsolve(diff(D2w) == -w, w(0)==1, Dw(0)==0, D2w(0)==0)
 
    See also <a href="matlab:help cgdivexpr/solve">solve</a>, <a href="matlab:help subs">subs</a>, <a href="matlab:help sym/diff">sym/diff</a>, <a href="matlab:help odeToVectorField">odeToVectorField</a>.

    <a href="matlab:doc dsolve">Documentation for dsolve</a>

dsolve(d2x+5*dx+6*x,x(0)==0, dx(0)==7)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dsolve(d2x+5*dx+6*x, x(0) == 0, dx(0 )== 7)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dx
 
dx =
 
diff(x(t), t)
 
d2x
 
d2x =
 
diff(x(t), t, t)
 
diff(x,2)
 
ans(t) =
 
diff(x(t), t, t)
 
dsolve(d2x+5*dx+6*x == 0, x(0) == 0, dx(0 )== 7)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dsolve(d2x+5*dx+6*x == 0, x(0) == 0, dx(0) == 7)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dx
 
dx =
 
diff(x(t), t)
 
dx(0)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dsolve(d2x+5*dx+6*x == 0, x(0) == 0, dx(0)==7)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dx
 
dx =
 
diff(x(t), t)
 
dsolve(d2x+5*dx+6*x == 0, x(0)==0, dx(0)==7)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
dx
 
dx =
 
diff(x(t), t)
 
dx(0)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
x
 
x(t) =
 
x(t)
 
dx
 
dx =
 
diff(x(t), t)
 
d2x
 
d2x =
 
diff(x(t), t, t)
 
clear ans F_s s 
t
 
t =
 
t
 
x
 
x(t) =
 
x(t)
 
dx
 
dx =
 
diff(x(t), t)
 
d2x
 
d2x =
 
diff(x(t), t, t)
 
d2x(0)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
help laplace
--- help for <strong>sym/laplace</strong> ---

 <strong>laplace</strong> Laplace transform.
    L = <strong>laplace</strong>(F) is the Laplace transform of the sym F with default
    independent variable t.  The default return is a function of s.
    If F = F(s), then <strong>laplace</strong> returns a function of z:  L = L(z).
    By definition, L(s) = int(F(t)*exp(-s*t),t,0,inf).
 
    L = <strong>laplace</strong>(F,z) makes L a function of z instead of the default s:
    <strong>laplace</strong>(F,z) <=> L(z) = int(F(t)*exp(-z*t),t,0,inf).
 
    L = <strong>laplace</strong>(F,w,u) makes L a function of u instead of the
    default s (integration with respect to w).
    <strong>laplace</strong>(F,w,u) <=> L(u) = int(F(w)*exp(-u*w),w,0,inf).
 
    Examples:
     syms a s t w x F(t)
     laplace(t^5)          returns   120/s^6
     laplace(exp(a*s))     returns   -1/(a-z)
     laplace(sin(w*x),t)   returns   w/(t^2+w^2)
     laplace(cos(x*w),w,t) returns   t/(t^2+x^2)
     laplace(x^(3/2),t)    returns   (3*pi^(1/2))/(4*t^(5/2))
     laplace(diff(F(t)))   returns   s*laplace(F(t),t,s) - F(0)
 
    See also <a href="matlab:help sym/ilaplace">sym/ilaplace</a>, <a href="matlab:help sym/fourier">sym/fourier</a>, <a href="matlab:help sym/htrans">sym/htrans</a>, <a href="matlab:help sym/ztrans">sym/ztrans</a>, <a href="matlab:help sym/subs">subs</a>.

help dsolve
 <strong>dsolve</strong> Symbolic solution of ordinary differential equations.
    <strong>dsolve</strong> will not accept equations as strings in a future release.
    Use symbolic expressions or sym objects instead.
    For example, use syms y(t); dsolve(diff(y)==y) instead of  dsolve('Dy=y').
 
    <strong>dsolve</strong>(eqn1,eqn2, ...) accepts symbolic equations representing
    ordinary differential equations and initial conditions. 
 
    By default, the independent variable is 't'. The independent variable
    may be changed from 't' to some other symbolic variable by including
    that variable as the last input argument.
 
    The DIFF function constructs derivatives of symbolic functions (see sym/symfun).
    Initial conditions involving derivatives must use an intermediate
    variable. For example,
      syms x(t)
      Dx = diff(x);
      dsolve(diff(Dx) == -x, Dx(0) == 1)
 
    If the number of initial conditions given is less than the
    number of dependent variables, the resulting solutions will obtain
    arbitrary constants, C1, C2, etc.
    
    Three different types of output are possible.  For one equation and one
    output, the resulting solution is returned, with multiple solutions to
    a nonlinear equation in a symbolic vector.  For several equations and
    an equal number of outputs, the results are sorted in lexicographic
    order and assigned to the outputs.  For several equations and a single
    output, a structure containing the solutions is returned.
 
    If no closed-form (explicit) solution is found, then a
    warning is given and the empty sym is returned.  
  
    <strong>dsolve</strong>(...,'IgnoreAnalyticConstraints',VAL) controls the level of 
    mathematical rigor to use on the analytical constraints of the solution 
    (branch cuts, division by zero, etc). The options for VAL are TRUE or 
    FALSE. Specify FALSE to use the highest level of mathematical rigor
    in finding any solutions. The default is TRUE.
 
    <strong>dsolve</strong>(...,'MaxDegree',n) controls the maximum degree of polynomials
    for which explicit formulas will be used in SOLVE calls during the
    computation. n must be a positive integer smaller than 5. 
    The default is 2.
 
    <strong>dsolve</strong>(...,'Implicit',true) returns the solution as a vector of
    equations, relating the dependent and the independent variable. This
    option is not allowed for systems of differential equations.
 
    <strong>dsolve</strong>(...,'ExpansionPoint',a) returns the solution as a series around
    the expansion point a.
 
    <strong>dsolve</strong>(...,'Order',n) returns the solution as a series with order n-1.
 
    Examples:
 
       % Example 1
       syms x(t) a
       dsolve(diff(x) == -a*x) returns
 
         ans = C1/exp(a*t)
 
       % Example 2: changing the independent variable 
       x = dsolve(diff(x) == -a*x, x(0) == 1, 's') returns
 
         x = 1/exp(a*s)
 
       syms x(s) a
       x = dsolve(diff(x) == -a*x, x(0) == 1) returns
 
         x = 1/exp(a*s)
 
       % Example 3: solving systems of ODEs
       syms f(t) g(t)
       S = dsolve(diff(f) == f + g, diff(g) == -f + g,f(0) == 1,g(0) == 2)
       returns a structure S with fields
 
         S.f = (i + 1/2)/exp(t*(i - 1)) - exp(t*(i + 1))*(i - 1/2)
         S.g = exp(t*(i + 1))*(i/2 + 1) - (i/2 - 1)/exp(t*(i - 1))
 
       syms f(t) g(t)
       v = [f;g];
       A = [1 1; -1 1];
       S = dsolve(diff(v) == A*v, v(0) == [1;2])
       returns a structure S with fields
 
         S.f = exp(t)*cos(t) + 2*exp(t)*sin(t)
         S.g = 2*exp(t)*cos(t) - exp(t)*sin(t)
 
       % Example 3: using options
       syms y(t)
       dsolve(sqrt(diff(y))==y) returns
       
         ans = 0
       
       syms y(t)
       dsolve(sqrt(diff(y))==y, 'IgnoreAnalyticConstraints', false) warns
         Warning: The solutions are subject to the following conditions:
         (C67 + t)*(1/(C67 + t)^2)^(1/2) = -1 
       
       and returns
        
         ans = -1/(C67 + t)
 
       % Example 4: Higher order systems
       syms y(t) a
       Dy = diff(y);
       D2y = diff(y,2);
       dsolve(D2y == -a^2*y, y(0) == 1, Dy(pi/a) == 0)
       syms w(t)
       Dw = diff(w); 
       D2w = diff(w,2);
       w = dsolve(diff(D2w) == -w, w(0)==1, Dw(0)==0, D2w(0)==0)
 
    See also <a href="matlab:help cgdivexpr/solve">solve</a>, <a href="matlab:help subs">subs</a>, <a href="matlab:help sym/diff">sym/diff</a>, <a href="matlab:help odeToVectorField">odeToVectorField</a>.

    <a href="matlab:doc dsolve">Documentation for dsolve</a>

syms x(t)
x
 
x(t) =
 
x(t)
 
clear x
syms x(t)
x
 
x(t) =
 
x(t)
 
dsolve(d2x+5*dx+6*x == 0, x(0)==0, dx(0)==7)
{Array indices must be positive integers or logical values.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('sym/subsref', 'C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m', 902)" style="font-weight:bold">sym/subsref</a> (<a href="matlab: opentoline('C:\Program Files\Polyspace\R2020b\toolbox\symbolic\symbolic\@sym\sym.m',902,0)">line 902</a>)
            R_tilde = builtin('subsref',L_tilde,Idx);
} 
x
 
x(t) =
 
x(t)
 
clear
syms x(t)
t
 
t =
 
t
 
x
 
x(t) =
 
x(t)
 
dx=diff(x)
 
dx(t) =
 
diff(x(t), t)
 
d2x=diff(x,2)
 
d2x(t) =
 
diff(x(t), t, t)
 
dsolve(d2x+5*dx+6*x == 0, x(0)==0, dx(0)==7)
 
ans =
 
7*exp(-3*t)*(exp(t) - 1)
 
clc
clear
syms A x t
int(A*cos(2*x*t),x,0,pi/2)
 
ans =
 
(A*sin(pi*t))/(2*t)
 
x
 
x =
 
x
 
f=x^2+4*x+3
 
f =
 
x^2 + 4*x + 3
 
limit(f)
 
ans =
 
3
 
limit(f,1)
 
ans =
 
8
 
clc
clc
lookfor tcp
<a href="matlab:help initcp">initcp</a>                         - Initialize variables in the demo slcp.m
<a href="matlab:help initcp1">initcp1</a>                        - Initialize variables in the demo slcp1.m
<a href="matlab:help initcpp1">initcpp1</a>                       - Initialize variables in the demo slcpp1.m
<a href="matlab:help ublaze_lwip_read_write_vector_test">ublaze_lwip_read_write_vector_test</a> - Read and Write the IP Core via TCP/IP and AXI4-Lite
<a href="matlab:help tcpip">tcpip</a>                          - Construct TCPIP client or server object.
<a href="matlab:help stcpiprb">stcpiprb</a>                       - Underlying S-Function for the ICT TCPIP Receive block. 
<a href="matlab:help stcpipsb">stcpipsb</a>                       - Underlying S-Function for the ICT TCPIP Send block. 
<a href="matlab:help privateslsfcncreatenetworkobject">privateslsfcncreatenetworkobject</a> - Creates the network object for UDP/TCPIP blocks.
<a href="matlab:help privateslsfcnterminatenetworkobject">privateslsfcnterminatenetworkobject</a> - Cleanup for TCPIP/UDP blocks during simulation
<a href="matlab:help findTCPPort">findTCPPort</a>                    - Find a open port on the local machine.
<a href="matlab:help echotcpip">echotcpip</a>                      - start or stop a TCP/IP echo server.
<a href="matlab:help tcpclient">tcpclient</a>                      - Create TCP/IP client object
help pause
 <strong>pause</strong> Wait for user response.
    <strong>pause</strong>(n) pauses for n seconds before continuing, where n can also be a
    fraction. The resolution of the clock is platform specific. Fractional
    pauses of 0.01 seconds should be supported on most platforms.
 
    <strong>pause</strong> causes a procedure to stop and wait for the user to strike any
    key before continuing.
 
    <strong>pause</strong> OFF indicates that any subsequent <strong>pause</strong> or <strong>pause</strong>(n) commands
    should not actually pause. This allows normally interactive scripts to
    run unattended.
 
    <strong>pause</strong> ON indicates that subsequent <strong>pause</strong> commands should pause.
 
    <strong>pause</strong> QUERY returns the current state of pause, either 'on' or 'off'.
 
    STATE = <strong>pause</strong>(...) returns the state of pause previous to processing
    the input arguments.
 
    The accuracy of <strong>pause</strong> is subject to the scheduling resolution of the
    operating system you are using and also to other system activity. It
    cannot be guaranteed with 100% confidence, but only with some expected
    error. For example, experiments have shown that choosing N with a
    resolution of .1 (such as N = 1.7) leads to actual pause values that
    are correct to roughly 10% in the relative error of the fractional
    part. Asking for finer resolutions (such as .01) shows higher relative
    error.
 
    Examples:
        % Pause for 5 seconds
        pause(5)
 
        % Temporarily disable pause
        pause off
        pause(5) % Note that this does not pause
        pause on
 
        % Alternatively, disable/restore the state
        pstate = pause('off')
        pause(5) % Note that this does not pause
        pause(pstate);
 
    See also <a href="matlab:help keyboard">keyboard</a>, <a href="matlab:help input">input</a>.

    <a href="matlab:doc pause">Documentation for pause</a>

exit
